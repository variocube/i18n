#!/usr/bin/env -S node --loader ts-node/esm

import {createReadStream, createWriteStream, existsSync, mkdirSync, readdirSync, writeFileSync} from "fs";
import {dirname, join, parse as parsePath} from "path";
import {parse} from "@fast-csv/parse";
import {format} from "@fast-csv/format";
import {Messages, MultiLingualMessages} from "./messages.js";
import {readFile} from "fs/promises";

const DEFAULT_LANGUAGES = ["en", "de"];

for (const packageJson of findPackages(process.cwd())) {
    await syncPackage(packageJson);
}

function findPackages(dir: string) {
    const packageJsons: string[] = [];
    for (const file of readdirSync(dir, {withFileTypes: true})) {
        if (file.name == "package.json") {
            packageJsons.push(join(dir, file.name));
        }
        else if (file.isDirectory()) {
            packageJsons.push(...findPackages(join(dir, file.name)));
        }
    }
    return packageJsons;
}

async function readPackageInfo(packageDir: string) {
    const {i18n} = JSON.parse(await readFile(join(packageDir, "package.json"), {encoding: "utf-8"})) as Record<string, any>;
    if (i18n) {
        if (typeof i18n != "object") {
            throw new Error("The i18n property in package.json must be an object.");
        }
        const messages = i18n.messages;
        if (!messages) {
            throw new Error("Missing property i18n.messages in package.json.");
        }
        if (typeof messages != "string") {
            throw new Error("The i18n.messages property must a string.");
        }
        const messagesFile = join(packageDir, messages);
        if (!existsSync(messagesFile)) {
            throw new Error("Could not find messages file:" + messagesFile);
        }
        const languages = i18n.languages;
        if (languages) {
            if (!Array.isArray(languages)) {
                throw new Error("The i18n.languages property must be an array.");
            }
            for (const lang of languages) {
                if (typeof lang != "string") {
                    throw new Error("The i18n.languages property must be an array of strings.");
                }
            }
        }
        return {
            messagesFile,
            languages: languages as string[] | undefined,
        }
    }
}

async function syncPackage(packageJson: string) {
    const packageDir = dirname(packageJson);
    console.log("Processing package: ", packageDir);

    const packageInfo = await readPackageInfo(packageDir);

    if (packageInfo) {
        console.log("  Found i18n in package.json");

        const {
            messagesFile,
            languages = DEFAULT_LANGUAGES,
        } = packageInfo;

        const messagesModule = await import(messagesFile);
        const messages = messagesModule?.messages || messagesModule?.default as Messages<string, MultiLingualMessages<string>>;
        if (!messages) {
            console.error("Failed to load messages. Could not find `messages` or default export.");
            return;
        }

        // Ensure i18n dir
        const i18nDir = join(packageDir, "i18n");
        mkdirSync(i18nDir, {recursive: true});

        // Read current translations
        const translations = await readTranslations(i18nDir);

        // Convert them to a TS file
        writeFileSync(join(i18nDir, "import.ts"), "// Auto-generated by i18n-sync.\nexport default " + JSON.stringify(translations));

        console.log("  Created/updated i18n/import.ts");

        //
        // Export current message to CSV files
        //
        const exportLanguages = languages.filter(lang => !messages.isInternalLanguage(lang));

        for (const lang of exportLanguages) {
            const enMessages = messages.getMessages("en");
            const langMessages = messages.getMessagesWithoutFallback(lang) || {};

            const stream = format({headers: ["key", "en", lang]});
            stream.pipe(createWriteStream(join(i18nDir, `${lang}.csv`)));
            for (const [key, enValue] of Object.entries(enMessages)) {
                stream.write([key, enValue, langMessages[key]]);
            }
            stream.end();
        }

        console.log("  Exported CSV files.");
    }
    else {
        console.log("  No i18n in package.json found. Skipping package.");
    }
}

type Translations = Record<string, Record<string, string>>;

async function readTranslations(i18nDir: string) {
    const messages: Translations = {};

    for (const file of readdirSync(i18nDir)) {
        if (file.endsWith(".csv")) {
            const langMessages = await parseFile(join(i18nDir, file));
            for (const [key, value] of Object.entries(langMessages)) {
                messages[key] = {
                    ...messages[key],
                    ...value
                }
            }
        }
    }
    return messages;
}

function parseFile(path: string) {
    return new Promise<Translations>((resolve, reject) => {
        const messages: Translations = {};
        const lang = parsePath(path).name;

        createReadStream(path)
            .pipe(parse({headers: true, trim: true}))
            .on("data", row => {
                const value = row[lang];
                if (value) {
                    messages[row["key"]] = {
                        [lang]: value
                    };
                }
            })
            .on("end", () => resolve(messages))
            .on("error", reject);
    });
}
